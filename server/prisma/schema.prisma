// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------- ENUMS ----------

enum ActivityLevel {
  SEDENTARY
  LIGHT
  MODERATE
  ACTIVE
  VERY_ACTIVE
}

enum FoodSource {
  MANUAL // user typed it in
  UPC_API // fetched from barcode/UPC API
  PHOTO_API // estimated via photo API
}

enum MealType {
  BREAKFAST
  LUNCH
  DINNER
  SNACK
  OTHER
}

enum VerificationTokenType {
  EMAIL_VERIFY
  PASSWORD_RESET
}

// ---------- MODELS ----------

// Auth + basic profile
model User {
  id    String @id @default(uuid())
  email String @unique

  // ✅ Email/password login (nullable for Google-only users)
  passwordHash String?

  // ✅ Google login
  googleSub String? @unique // Google's stable user id ("sub")
  photoUrl  String?

  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // profile / health info (optional for now)
  dateOfBirth   DateTime?
  gender        String?
  timezone      String?        @default("America/Chicago")
  heightCm      Float?
  weightKg      Float?
  activityLevel ActivityLevel?

  // privacy / terms
  isVerified      Boolean   @default(false)
  acceptedTermsAt DateTime?

  // relations
  allergies          UserAllergy[]
  meals              Meal[]
  symptomLogs        SymptomLog[]
  verificationTokens VerificationToken[]
}

// Master list of allergies (e.g., Peanuts, Gluten, Lactose)
model Allergy {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?

  foods         FoodAllergen[]
  userAllergies UserAllergy[]
}

// Join: which user has which allergy
model UserAllergy {
  id Int @id @default(autoincrement())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  allergy   Allergy @relation(fields: [allergyId], references: [id], onDelete: Cascade)
  allergyId Int

  severity Int?
  note     String?

  @@unique([userId, allergyId])
}

// Food catalog: manual entries + UPC + photo
model Food {
  id          Int     @id @default(autoincrement())
  name        String
  brand       String?
  description String?

  servingSize Float?
  servingUnit String?

  calories Float?
  protein  Float?
  carbs    Float?
  fat      Float?
  fiber    Float?
  sugar    Float?
  sodium   Float?

  barcode    String?    @unique
  imageUrl   String?
  source     FoodSource @default(MANUAL)
  externalId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mealItems MealItem[]
  allergens FoodAllergen[]
}

// Join: which food contains which allergy
model FoodAllergen {
  id Int @id @default(autoincrement())

  food   Food @relation(fields: [foodId], references: [id], onDelete: Cascade)
  foodId Int

  allergy   Allergy @relation(fields: [allergyId], references: [id], onDelete: Cascade)
  allergyId Int

  contains Boolean @default(true)
  level    String?

  @@unique([foodId, allergyId])
}

// One meal event per user per time
model Meal {
  id Int @id @default(autoincrement())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  dateTime DateTime
  mealType MealType
  note     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items       MealItem[]
  symptomLogs SymptomLog[] @relation("MealSymptoms")
}

// Join between Meal and Food, with quantity and nutrition snapshot
model MealItem {
  id Int @id @default(autoincrement())

  meal   Meal @relation(fields: [mealId], references: [id], onDelete: Cascade)
  mealId Int

  food   Food @relation(fields: [foodId], references: [id], onDelete: Restrict)
  foodId Int

  quantity Float   @default(1)
  unit     String?
  notes    String?

  calories Float?
  protein  Float?
  carbs    Float?
  fat      Float?
  fiber    Float?
  sugar    Float?
  sodium   Float?
}

// Master list of possible symptoms
model Symptom {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?

  logs SymptomLog[]
}

// Logged symptom entry for a user
model SymptomLog {
  id Int @id @default(autoincrement())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  symptom   Symptom @relation(fields: [symptomId], references: [id], onDelete: Restrict)
  symptomId Int

  startedAt DateTime @default(now())
  severity  Int?
  notes     String?

  relatedMeal   Meal? @relation("MealSymptoms", fields: [relatedMealId], references: [id])
  relatedMealId Int?

  createdAt DateTime @default(now())
}

// Tokens for email verification and password reset
model VerificationToken {
  id Int @id @default(autoincrement())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  token     String                @unique
  type      VerificationTokenType
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime              @default(now())
}
